import _regeneratorRuntime from 'babel-runtime/regenerator';

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { step("next", value); }, function (err) { step("throw", err); }); } } return step("next"); }); }; }

import * as React from 'react';
import { decode } from './ghost-string';
import { CLOSE_STR, OPEN_STR, parseWrappedStringLinkedList, stripWrappedString } from './string-utils';
import ModalContent from './Modal/ModalContent';
import { highlightActiveBadge, unHighlightActiveBadge, updateDOM, updateDOMAttr } from './dom-utils';
import { getOffset } from './utils';
import Modal from './Modal';
import cn from './classnames';

export var RAW_DATA_SEP = '\u200F';
var open = Modal.open;


function proxyEvents(props) {
  var config = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  return Object.keys(config).reduce(function (map, name) {
    if (typeof config[name] === 'function') {
      var fn = props[name];
      map[name] = function () {
        if (typeof fn === 'function') {
          fn.apply(this, arguments);
        }
        config[name].apply(this, arguments);
      };
    }
    return map;
  }, {});
}

export function parseTranslatedString(encodedValue) {
  var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
      _ref$strip = _ref.strip,
      strip = _ref$strip === undefined ? true : _ref$strip,
      _ref$data = _ref.data,
      data = _ref$data === undefined ? true : _ref$data;

  var dataList = [];

  var rawContent = stripWrappedString(encodedValue, {
    transform: function transform(chunk, _ref2) {
      var openStr = _ref2.openStr,
          closeStr = _ref2.closeStr;

      var pos = chunk.split('').lastIndexOf(RAW_DATA_SEP);
      if (pos >= 0) {
        data && dataList.push(JSON.parse(decode(chunk.slice(pos + 1))));
        return chunk.slice(0, pos);
      }
      return chunk;
    }
  });

  return {
    dataList: dataList,
    rawContent: rawContent
  };
}

export function translatedStringI18n(encodedValue, tinyI18n) {
  var dataList = [];

  var rawContent = stripWrappedString(encodedValue, {
    transform: function transform(chunk, _ref3) {
      var openStr = _ref3.openStr,
          closeStr = _ref3.closeStr;

      var pos = chunk.split('').lastIndexOf(RAW_DATA_SEP);
      if (pos >= 0) {
        var _JSON$parse = JSON.parse(decode(chunk.slice(pos + 1))),
            key = _JSON$parse[0],
            argv = _JSON$parse[1];
        // www


        argv = argv.map(function (x) {
          return parseTranslatedString(x).rawContent;
        });
        dataList.push([key, argv]);
        return tinyI18n.i18n.apply(tinyI18n, [key].concat(argv));
      }
      return chunk;
    }
  });
  return {
    rawContent: rawContent,
    dataList: dataList
  };
}

export default function createI18nWrapper() {
  var _ref4 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
      badge = _ref4.badge,
      createElement = _ref4.createElement,
      transaction = _ref4.transaction,
      originTinyI18n = _ref4.originTinyI18n,
      tinyI18n = _ref4.tinyI18n,
      highlight = _ref4.highlight;

  return function I18nWrapper(_ref5) {
    var children = _ref5.children;

    var newProps = void 0;
    var uniqDataMap = new Map();
    var i18nWhereMap = new Map();
    var handleTranslatedString = function handleTranslatedString(value, where) {
      var _translatedStringI18n = translatedStringI18n(value, originTinyI18n),
          dataList = _translatedStringI18n.dataList,
          rawContent = _translatedStringI18n.rawContent;

      where && dataList.forEach(function (dataValue, i) {
        try {
          var key = dataValue[0],
              data = dataValue[1];


          if (key) {
            var array = !i18nWhereMap.get(key) ? [] : i18nWhereMap.get(key);
            array.push([where, value]);

            i18nWhereMap.set(key, array);
            uniqDataMap.set(key, data);
          }
        } catch (e) {}
      });
      return rawContent;
    };

    var config = _extends({}, children.props);
    delete config.children;
    // hmr update loop
    //
    delete config['data-i18n-react-live'];
    var names = Object.keys(config);
    names.forEach(function (configKey) {
      var node = config[configKey];
      if (typeof node === 'string') {
        config[configKey] = handleTranslatedString(node, configKey);
      }
    });

    var newChildren = React.Children.toArray(children.props.children).map(function (node, index) {
      if (typeof node === 'string') {
        return handleTranslatedString(node, 'children[' + index + ']');
      }
      return node;
    });

    if (!uniqDataMap.size) {
      return children;
    }

    newProps = _extends({}, config, {
      className: cn(config.className, '__i18n-translated'),
      'data-i18n-react-live': JSON.stringify(Array.from(i18nWhereMap.keys()).reduce(function (acc, n) {
        acc[n] = i18nWhereMap.get(n);
        return acc;
      }, {}))
    }, proxyEvents(config, {
      onMouseEnter: function onMouseEnter(_ref6) {
        var _this = this;

        var target = _ref6.target;

        var keys = Array.from(uniqDataMap.keys());
        badge.close();
        var ctx = {};

        var argsGetter = function argsGetter(key, lang) {
          return uniqDataMap.get(key).map(function (argVal) {
            var cLang = void 0;
            if (lang) {
              cLang = originTinyI18n.getCurrentLanguage();
              originTinyI18n.setLanguage(lang);
            }
            var result = translatedStringI18n(argVal, originTinyI18n).rawContent;
            if (cLang) {
              originTinyI18n.setLanguage(cLang);
            }
            return result;
          });
        };
        var argsGetterList = keys.map(function (key) {
          return function (lang) {
            return argsGetter(key, lang);
          };
        });
        var translate = function translate(key, lang) {
          var cLang = originTinyI18n.getCurrentLanguage();
          originTinyI18n.setLanguage(lang);
          var args = argsGetter(key);
          var string = originTinyI18n.i18n.apply(originTinyI18n, [key].concat(args));
          originTinyI18n.setLanguage(cLang);
          return string;
        };
        var content = React.createElement(ModalContent, {
          createElement: createElement,
          transaction: transaction,
          tinyI18n: originTinyI18n,
          onClose: unHighlightActiveBadge,
          onActiveUpdate: function onActiveUpdate(newId, oldId) {
            unHighlightActiveBadge();
            highlightActiveBadge(newId);
          },
          ref: function ref(_ref8) {
            return ctx.content = _ref8;
          },
          keyList: keys,
          translatedGetterList: keys.map(function (key) {
            return function (lang) {
              return translate(key, lang);
            };
          }),
          argsGetterList: argsGetterList,
          inputValueList: keys.map(function (key) {
            return tinyI18n.getWord(key);
          }),
          onSave: function () {
            var _ref7 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(data) {
              var passed, _tinyI18n$extendDicti, index, encodedValue;

              return _regeneratorRuntime.wrap(function _callee$(_context) {
                while (1) {
                  switch (_context.prev = _context.next) {
                    case 0:
                      _context.next = 2;
                      return transaction.update({
                        id: data.data.id,
                        value: data.value
                      });

                    case 2:
                      passed = _context.sent;

                      if (passed) {
                        tinyI18n.extendDictionary((_tinyI18n$extendDicti = {}, _tinyI18n$extendDicti[data.data.id] = data.value, _tinyI18n$extendDicti), ctx.content.lang);

                        index = ctx.content.state.index;

                        if (ctx.content.lang === tinyI18n.getCurrentLanguage()) {
                          encodedValue = tinyI18n.i18n.apply(null, [data.data.id].concat(argsGetterList[index](ctx.content.lang)));

                          updateDOMAttr(target, data.data.id, {
                            encodedValue: encodedValue,
                            stripedValue: parseTranslatedString(encodedValue, {
                              data: false
                            }).rawContent
                          });
                        }

                        ctx.content.forceUpdate();
                        transaction.emit('afterUpdate', _extends({ lang: ctx.content.lang }, data));
                      }

                    case 4:
                    case 'end':
                      return _context.stop();
                  }
                }
              }, _callee, _this);
            }));

            return function (_x4) {
              return _ref7.apply(this, arguments);
            };
          }()
        });
        var dom = badge.open({
          onClick: function onClick() {
            open({ children: content });
          }
        });

        var _getOffset = getOffset(target),
            top = _getOffset.top,
            left = _getOffset.left;

        Object.assign(dom.style, {
          position: 'absolute',
          top: top + 'px',
          left: left + 'px',
          zIndex: 999999
        });
      }
    }), {
      children: newChildren
    });

    return React.cloneElement(children, newProps);
  };
}